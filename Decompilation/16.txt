Выполним команду:
objdump -d ./16 > dump_16.txt
Находим функцию main:
0000000000000725 <main>:
 725:	55                   	push   %rbp
 726:	48 89 e5             	mov    %rsp,%rbp
 729:	48 83 ec 20          	sub    $0x20,%rsp
 72d:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
 734:	00 00 
 736:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 73a:	31 c0                	xor    %eax,%eax
 73c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
 743:	48 8d 3d 0a 01 00 00 	lea    0x10a(%rip),%rdi        # 854 <_IO_stdin_used+0x4>
 74a:	b8 00 00 00 00       	mov    $0x0,%eax
 74f:	e8 6c fe ff ff       	callq  5c0 <printf@plt>
 754:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
 758:	48 89 c6             	mov    %rax,%rsi
 75b:	48 8d 3d fc 00 00 00 	lea    0xfc(%rip),%rdi        # 85e <_IO_stdin_used+0xe>
 762:	b8 00 00 00 00       	mov    $0x0,%eax
 767:	e8 64 fe ff ff       	callq  5d0 <scanf@plt>
 76c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
 773:	8b 45 ec             	mov    -0x14(%rbp),%eax
 776:	39 45 f4             	cmp    %eax,-0xc(%rbp)
 779:	7f 22                	jg     79d <main+0x78>
 77b:	8b 45 f4             	mov    -0xc(%rbp),%eax
 77e:	89 c7                	mov    %eax,%edi
 780:	e8 75 ff ff ff       	callq  6fa <_Z1fi>
 785:	01 45 f0             	add    %eax,-0x10(%rbp)
 788:	8b 0d 82 08 20 00    	mov    0x200882(%rip),%ecx        # 201010 <mod>
 78e:	8b 45 f0             	mov    -0x10(%rbp),%eax
 791:	99                   	cltd   
 792:	f7 f9                	idiv   %ecx
 794:	89 55 f0             	mov    %edx,-0x10(%rbp)
 797:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 79b:	eb d6                	jmp    773 <main+0x4e>
 79d:	8b 45 f0             	mov    -0x10(%rbp),%eax
 7a0:	89 c6                	mov    %eax,%esi
 7a2:	48 8d 3d b8 00 00 00 	lea    0xb8(%rip),%rdi        # 861 <_IO_stdin_used+0x11>
 7a9:	b8 00 00 00 00       	mov    $0x0,%eax
 7ae:	e8 0d fe ff ff       	callq  5c0 <printf@plt>
 7b3:	b8 00 00 00 00       	mov    $0x0,%eax
 7b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 7bc:	64 48 33 14 25 28 00 	xor    %fs:0x28,%rdx
 7c3:	00 00 
 7c5:	74 05                	je     7cc <main+0xa7>
 7c7:	e8 e4 fd ff ff       	callq  5b0 <__stack_chk_fail@plt>
 7cc:	c9                   	leaveq 
 7cd:	c3                   	retq   
 7ce:	66 90                	xchg   %ax,%ax

Функция начинается со стандартного пролога: на стеке сохраняется базовый
указатель предшествующей функции и создается базовый указатель текущей:
    push   %rbp
    mov    %rsp,%rbp

На стеке выделяется место для переменных:
    sub    $0x20,%rsp

В переменную на стеке, имеющую относительный адрес rbp-0x8 (здесь и далее
адреса в шестнадцатиричной системе), сохраняется некоторое неизвестное
значение. Эта переменная используется для проверки целостности стека и на
поведение программы в целом не влияет. Назовем эту переменную var_8.
    mov    %fs:0x28,%rax
    mov    %rax,-0x8(%rbp)

Регистр eax обнуляется (оптимизация компилятора, связанная с особенностями
работы функций с переменным количеством аргументов, такими как printf) , в
регистр rdi записывается адрес ячейки памяти, в которой хранится строка "Enter
N: ", и далее вызывается функция printf (также здесь переменная в ячейке
rbp-0x10 (назовем ее var_10) обнуляется).
    xor    %eax,%eax
    movl   $0x0,-0x10(%rbp)
    lea    0x10a(%rip),%rdi        # 854 <_IO_stdin_used+0x4>
    mov    $0x0,%eax
    callq  5c0 <printf@plt>
Это было установлено следующим образом. При запуске программы она выводит
строку "Enter N: " и ожидает ввода пользовательских данных. Во-первых, регистр
rdi часто служит в качестве хранилища для первого аргумента вызываемой функции.
Во-вторых, почти сразу же после этого вызывается функция printf, которая
требует минимум одного аргумента. В-третьих, далее по тексту идет вызов функции
scanf, которая и приводит к ожиданию ввода данных, и ни между ней и текущим
вызовом printf, ни до этого нет ни одной инструкции, которая могла бы привести
к выводу каких-либо данных на экран.
Восстановленный исходный код для этого фрагмента выглядит следующим образом:
    var_10 = 0;
    printf("Enter N: ");

В регистр rsi загружается адрес переменной в ячейке rbp-0x14 (назовем ее
var_14). В регистр rdi загружается, вероятнее всего, строка форматирования
(т.к. далее вызывается scanf, который использует rdi в качестве первого
аргумента, а rsi -- в качестве второго).
    lea    -0x14(%rbp),%rax
    mov    %rax,%rsi
    lea    0xfc(%rip),%rdi        # 85e <_IO_stdin_used+0xe>
    mov    $0x0,%eax
    callq  5d0 <scanf@plt>
В качестве рабочей гипотезы предположим, что первым аргументом scanf в данном
случае является строка "%d". Чтобы подтвердить ее, необходимо убедиться, что
var_14 является 32-битным знаковым целым, однако пока информации недостаточно.
Тем не менее, попробуем восстановить исходный код:
    scanf("%d", &var_14);

В ячейку памяти rbp-0xC (назовем соответствующую переменную var_C) загружается
значение 1. В регистр eax загружается переменная var_14. Переменная var_C и
var_14 сравниваются, если var_C больше, происходит переход с помощью инструкции
jg, означающей "переход если больше". У второй инструкции адрес 773, эта
информация пригодится в дальнейшем, т.к. далее по тексту встречается переход по
этому адресу. Здесь подтверждается предположение, что var_14 является 32-битным
целым.
    movl   $0x1,-0xc(%rbp)
773:
    mov    -0x14(%rbp),%eax
    cmp    %eax,-0xc(%rbp)
    jg     79d <main+0x78>
Восстановленный исходный код:
    var_C = 1;
l_773:
    if(var_14 < var_C) goto 79d;

В регистр edi загружается var_C и вызывается функция _Z1fi. Далее var_10
увеличивается на результат выполнения функции _Z1fi, в регистр ecx загружается
переменная mod, в eax загружается var_10, происходит знаковое расширение eax
(cltd) и целочисленное деление eax на ecx. В edx сохраняется остаток от деления
eax от ecx (т.е. остаток от деления var_10 на mod), и он записывается
в var_10.
    mov    -0xc(%rbp),%eax
    mov    %eax,%edi
    callq  6fa <_Z1fi>
    add    %eax,-0x10(%rbp)
    mov    0x200882(%rip),%ecx        # 201010 <mod>
    mov    -0x10(%rbp),%eax
    cltd   
    idiv   %ecx
    mov    %edx,-0x10(%rbp)
Восстановленный исходный код:
    res = _Z1fi(var_C);
    var_10 += res;
    var_10 = var_10 % mod;

var_C увеличивается на единицу и происходит безусловный переход по адресу 773:
    addl   $0x1,-0xc(%rbp)
    jmp    773 <main+0x4e>
Восстановленный исходный код:
    var_C += 1
    goto 773

var_10 загружается в esi, в rdi загружается адрес некоторой ячейки, eax
обнуляется, вызывается printf. Скорее всего, в rdi был загружен адрес строки
форматирования. Важно заметить, первая инструкция имеет адрес 79d. Ранее по
тексту программы был условный переход, ссылающийся на эту инструкцию.
79d:
    mov    -0x10(%rbp),%eax
    mov    %eax,%esi
    lea    0xb8(%rip),%rdi        # 861 <_IO_stdin_used+0x11>
    mov    $0x0,%eax
    callq  5c0 <printf@plt>
Вызовем следующую команду:
strings 16
В результате мы видим строки, которые есть в бинарном файле. Минимум одна как
раз нам подходит:
Result is %d
Пока что возьмем ее в качестве рабочей. Восстановленный исходный код:
l_79d:
    printf("Result is %d", var_10);

Здесь сравниваются переменная var_8 и значение, ранее сохраненное в эту
переменную. Таким образом программа проверяет, не поврежден ли стек. В случае
их неравенства программа вызывает функцию __stack_chk_fail, обрабатывающую
ошибку работы стека, если же значения равны, функция завершает свою работу.
    mov    $0x0,%eax
    mov    -0x8(%rbp),%rdx
    xor    %fs:0x28,%rdx
    je     7cc <main+0xa7>
    callq  5b0 <__stack_chk_fail@plt>
    leaveq 
    retq   
    xchg   %ax,%ax
Восстановленный исходный код. Т.к. проверку стека добавляет компилятор, в
исходном коде нет соответствующих ей инструкций:
    return 0;


Вероятный полный исходный код main (для удобства n -- var_14, acc -- var_10, var_c -- i):
    int acc = 0;
    int n;
    printf("Enter N: ");
    scanf("%d", &n);
    int i = 1;
l_773:
    if (n < i) goto l_79d;
    res = _Z1fi(var_C);
    acc += res;
    acc = var_10 % mod;
    i += 1;
    goto l_773;
l_79d:
    printf("Result is %d", acc);
    return 0;

Операторы goto и ветвления можно заменить одним циклом, а в переменной res нет
необходимости:

    int acc = 0;
    int n;
    printf("Enter N: ");
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        acc += _Z1fi(i);
        acc = acc % mod;
    }
    printf("Result is %d", acc);
    return 0;

_Z1fi начинается с пролога, как и main:
    push   %rbp
    mov    %rsp,%rbp

Переменная в ячейке rbp-0x14 (назовем ее var_14) сохраняет значение первого
аргумента функции, который был передан с помощью регистра edi. Затем переменным
rbp-0x8 (var_8) и rbp-0x4 (var_4) присваивается значение 1.
    mov    %edi,-0x14(%rbp)
    movl   $0x1,-0x8(%rbp)
    movl   $0x1,-0x4(%rbp
Восстановленный исходный код:
    var_8 = 1;
    var_4 = 1;

var_14 сравнивается с var_4, если var_4 больше, происходит переход по адресу
720. Первая инструкция имеет адрес 70f, по которому в дальнейшем возможно будет
совершаться переход:
70f:
    mov    -0x4(%rbp),%eax
    cmp    -0x14(%rbp),%eax
    jg     720 <_Z1fi+0x26>
Восстановленный исходный код:
l_70f:
    if (var_4 > var_14) goto l_720;

var_8 умножается на 2 за счет битового сдвига влево. К var_4 прибавляется 1.
Совершается безусловный переход по 70f.
    shll   -0x8(%rbp)
    addl   $0x1,-0x4(%rbp)
    jmp    70f <_Z1fi+0x15>
Восстановленный исходный код:
    var_8 *= 2;
    var_4++;
    goto l_70f;
 
 Значение var_8 сохраняется в регистре eax, т.к. он используется для возврата
 значений функцией, далее следует эпилог функции:
 720:
    mov    -0x8(%rbp),%eax
    pop    %rbp
    retq   
Восстановленный исходный код:
l_720:
    return var_8;

Вероятный исходный код функции _Z1fi (для удобства переименуем ее в f, n -- var_14, acc -- var_8, var_4 -- i):

int f(int n) {
    int acc = 1;
    int i = 1;
l_70f:
    if(i > n) goto l_720;
    acc *= 2;
    i++;
    goto l_70f;
l_720:
    return acc;
}

Эквивалентная версия:

int f(int n) {
    int acc = 1;
    for(int i = 1; i <= n; ++i) {
        acc *= 2;
    }
    return acc;
}

Функция f вычисляет степень двойки. Функция main вычисляет последовательность,
которая работает следующим образом. Мы вычисляем степень двойки по номеру
нового члена последовательности, после чего добавляем к предыдущему члену и
делим на некоторую переменную mod. Остаток и будет новым членом
последовательности.

Значение mod можно установить экспериментальным путем. Будем вводить в
программу числа от 1 до тех пор, пока результат не начнет отличаться от сумм
степеней двойки для i от 1 до n, где n -- текущее введенное число. Если
результат отличается, имея остаток и соответствующую сумму степеней мы
можем в точности установить модуль.

Вход: 1
Сумма: 2
Результат: 2

Вход: 2
Сумма: 6
Результат: 6

Вход: 3
Сумма: 14
Результат: 4

Итак, сумма 14, результат 4, следовательно модуль равен 10.