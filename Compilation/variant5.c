unsigned int fd2(unsigned int a, unsigned int b)
{
    return a / b;
}

/*
1. Параметры a и b передаются с помощью 32 битных регистров edi и esi
соответственно. Без оптимизаций clang копирует их на стек (видимо, это
стандартная процедура) для дальнейшего использования:
            mov     dword ptr [rbp - 4], edi
            mov     dword ptr [rbp - 8], esi
С флагом -O2 он использует их сразу:
            mov     eax, edi
            xor     edx, edx
            div     esi
            ret
*/

unsigned int fd3(unsigned int a)
{
    return a / 10;
}

/*
1. Аналогично, переменная a сохраняется на стеке:
    mov     dword ptr [rbp - 4], edi
С -O2:
        mov     ecx, edi
        mov     eax, 3435973837
        imul    rax, rcx
        shr     rax, 35
        ret
*/

unsigned int fd4(unsigned int a)
{
    return a % 16;
}

/*
1. То же самое:
     mov     dword ptr [rbp - 4], edi
Или:
        mov     eax, edi
        and     eax, 15
        ret
*/

int f(int a)
{
    switch (a)
    {
    case 1:
        return 5;
    case 6:
        return 7;
    case 10:
        return 3;
    case 12:
        return 4;
    case 62:
        return 1;
    case 20:
        return 8;
    }
    return 0;
}

/*
1. Здесь компилятор сохраняет параметр немного "позже" на стеке:
       mov     dword ptr [rbp - 8], edi
Это потому, что в rbp-4 сохраняется возвращаемое значение, например:
       mov     dword ptr [rbp - 4], 5
2. Оператор case реализован с помощью инструкций условного и безусловного
переходов. Например, компилятор копирует параметр a в регистр ecx и вычитает из
ecx единицу, таким образом как бы сравнивая параметр a с 1. При выполнении
операции вычитания факт того, что результат равен или не равен нулю сохраняет
флаг ZF (он будет принимать значения 1 и 0 соответственно). Если ZF равно
единице, то следующая за ней инструкция je .LBB0_1 приводит к переходу по
указанному адресу, в противном случае выполняется следующая инструкция jmp .LBB0_9:
        mov     eax, dword ptr [rbp - 8]
        mov     ecx, eax
        sub     ecx, 1
        mov     dword ptr [rbp - 12], eax # 4-byte Spill
        je      .LBB0_1
        jmp     .LBB0_9
По адресу .LBB0_1 код сохраняет число 5 по адресу rbp-4 и переходит по адресу .LBB0_8:
        mov     dword ptr [rbp - 4], 5
        jmp     .LBB0_8
По адресу .LBB0_8 расположен эпилог функции:
        mov     eax, dword ptr [rbp - 4]
        pop     rbp
        ret
Т.е. если 'a' равна единице, то совершается условный переход к коду, где на
стеке сохраняется значение 5, а затем выполняется эпилог функции, где из стека
копируется сохраненное ранее значение в регистр eax, где ожидается возвращаемое
значение функции. В противном случае, а именно при переходе по адресу .LBB0_9,
совершается следующая проверка:
        mov     eax, dword ptr [rbp - 12] # 4-byte Reload
        sub     eax, 6
        je      .LBB0_2
        jmp     .LBB0_10
Здесь либо происходит переход к коду, в котором происходит возврат значения 7,
либо переход к следующей проверке. Аналогичным описанному выше образом устроены
все остальные проверки.
*/

int f3(int a)
{
    switch (a)
    {
    case 3:
        return 5;
    case 5:
        return 7;
    case 6:
        return 3;
    case 8:
        return 4;
    case 9:
        return 1;
    case 7:
        return 8;
    }
    return 0;
}

/*
1. Так же, как и в предыдущем примере.
2. Здесь clang использует то преимущество, что в данном примере кода все кейсы
являются последовательностью чисел от 3 до 9. Из параметра 'a' вычитается число
-3, получившееся число сравнивается с числом 6. Например, если 'a' равно 2, то
2 - 3 = -1, и казалось бы -1 меньше 6, однако далее используется переход ja, с
точки зрения которого сравниваются числа без знака. -1 в дополнительном коде
32-разрядного числа это ffffffff, если интерпретировать это значение как
положительное число, то получится 4294967295, что больше 6. Если 'a' между 3 и
9, то переход ja .LBB0_7 не совершается, однако он совершается во всех
остальных случаях:
        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 8], edi
        mov     eax, dword ptr [rbp - 8]
        add     eax, -3
        mov     ecx, eax
        sub     eax, 6
        mov     qword ptr [rbp - 16], rcx # 8-byte Spill
        ja      .LBB0_7
По адресу .LBB0_7 находится код, который сохраняет значение 0 на стеке, после
чего сразу же идет эпилог функции:
        mov     dword ptr [rbp - 4], 0
.LBB0_8:
        mov     eax, dword ptr [rbp - 4]
        pop     rbp
        ret
В случае, если условный переход не происходит, программа вычисляет адрес, по
которому нужно перейти. Новый адрес -- это заранее сохраненное значение
расположенное по адресу 8*(a-3) + .LJTI0_0, т.е. в зависимости от того, каким
числом между 3 и 9 является 'a', в rcx сохраняется нужный для перехода адрес:
        mov     rax, qword ptr [rbp - 16] # 8-byte Reload
        mov     rcx, qword ptr [8*rax + .LJTI0_0]
        jmp     rcx
Сам сегмент .LJTI0_0 выглядит следующим образом:
        .quad   .LBB0_1
        .quad   .LBB0_7
        .quad   .LBB0_2
        .quad   .LBB0_3
        .quad   .LBB0_6
        .quad   .LBB0_4
        .quad   .LBB0_5
Например, если 'a' было равно 3, то 3-3 = 0, 8*0 + LJTI0_0 = LJTI0_0, т.е.
адрес, по которому сохранено значение .LBB0_1, соответственно при выполнении
инструкции jmp rcx  совершается переход по адресу .LBB0_1, где находится
следующий код:
        mov     dword ptr [rbp - 4], 5
        jmp     .LBB0_8
Т.е. на стеке сохраняется значение 5 и происходит переход к эпилогу функции.
*/

int if1(int a)
{
    int b = a == 0 ? 1 : 2;
    return b;
}

/*
1. 'a' передается через регистр edi и сохраняется на стеке:
    mov     dword ptr [rbp - 4], edi
5. 'b' хранится на стеке в ячейке rbp-8. Результат тернарного оператора был
сохранен в регистре ecx и скопирован в эту ячейку:
        mov     dword ptr [rbp - 8], ecx
*/

int if3(int a, int b, int c)
{
    if (a && c)
        return b;
    else
        return c;
}

/*
1. a, b и c передаются через регистры edi, esi и edx соответственно и
сохраняются в ячейках rbp-8, rbp-12 и rbp-16:
        mov     dword ptr [rbp - 8], edi
        mov     dword ptr [rbp - 12], esi
        mov     dword ptr [rbp - 16], edx
2. 'a' сравнивается с 0, в случае равенства происходит переход по адресу
.LBB0_3, где 'c' сохряняется в ячейке rbp-4, после чего сразу же идет эпилог
функции:
    .LBB0_3:
            mov     eax, dword ptr [rbp - 16]
            mov     dword ptr [rbp - 4], eax
    .LBB0_4:
            mov     eax, dword ptr [rbp - 4]
            pop     rbp
            ret
В противном случае 'b' сравнивается с 0 и аналогично переход происходит, либо
не происходит. Если он не происходит, т.е. и a, и b истинно, то в ячейке rbp-4
сохраняется 'b' и происходит безуслвоный переход к эпилогу функции:
        cmp     dword ptr [rbp - 8], 0
        je      .LBB0_3
        cmp     dword ptr [rbp - 16], 0
        je      .LBB0_3
        mov     eax, dword ptr [rbp - 12]
        mov     dword ptr [rbp - 4], eax
        jmp     .LBB0_4
*/

int if4(int a, int b, int c)
{
    if (a || c == b)
        return b;
    else
        return a;
}
/*
1. Так же, как и в предыдщуем примере.
2.
        cmp     dword ptr [rbp - 8], 0
        jne     .LBB0_2
        mov     eax, dword ptr [rbp - 16]
        cmp     eax, dword ptr [rbp - 12]
        jne     .LBB0_3
'a' сравнивается с 0, если оно не равно, то совершается условный переход по
адресу .LBB0_2, где 'b' сохраняется в ячейке rbp-4 и происходит безусловный
переход к эпилогу функции:
.LBB0_2:
        mov     eax, dword ptr [rbp - 12]
        mov     dword ptr [rbp - 4], eax
        jmp     .LBB0_4
В противном случае 'c' сравнивается с 'b', если они не равны, происходит
условный переход по адресу .LBB0_3, где 'a' сохряняется в ячейке rbp-4, после
чего сразу же следует эпилог функции:
.LBB0_3:
        mov     eax, dword ptr [rbp - 8]
        mov     dword ptr [rbp - 4], eax
.LBB0_4:
        mov     eax, dword ptr [rbp - 4]
        pop     rbp
        ret
В противном случае сразу же за этим кодом следует сегмент .LBB0_2.
*/

int *s[100];
int t[100];
void f2()
{
    for (int i = 0 ; i != 100 ; ++i)
        s[i] = &t[i];
}

/*
5. 'i' хранится в ячейке памяти rbp-4:
    mov     dword ptr [rbp - 4], 0
3. Весь цикл является сегментом .LBB0_1, после которого следует пролог функции
(сегмент .LBB0_4). В конце .LBB0_1 находится безусловный переход обратно к
началу сегмента (jmp .LBB0_1), прямо перед этим 'i' уменьшается на единицу. В
начале сегмента 'i' сравнивается с 100 и в зависимости от результата происходит
или не происходит переход к эпилогу функции (здесь код тела цикла заменен на
два троеточия для краткости): 
.LBB0_1:                                # =>This Inner Loop Header: Depth=1
        cmp     dword ptr [rbp - 4], 100
        je      .LBB0_4
        ...
        ...
        mov     eax, dword ptr [rbp - 4]
        add     eax, 1
        mov     dword ptr [rbp - 4], eax
        jmp     .LBB0_1
4. Первым делом вычисляется значение t+i. Де факто в C &t[i] является
синтаксическим сахаром для t+i. Для этого сначала происходит знаковое
расширение 'i' с 32 бит до 64, затем оно умножается на 4 (shl rax, 2), т.к.
массив t состоит из 32 битных ячеек (т.е. ячеек по 4 байта), в регистре rcx
сохраняется адрес массива t, и наконец к нему прибавляется смещение полученное
ранее:
        movsxd  rax, dword ptr [rbp - 4]
        shl     rax, 2
        movabs  rcx, offset t
        add     rcx, rax
Затем еще раз значение 'i' расширяется и вычисленное ранее значение &t[i],
которое хранится в rcx, сохраняется в ячейке памяти &*rax + s:
        movsxd  rax, dword ptr [rbp - 4]
        mov     qword ptr [8*rax + s], rcx
*/

void g();

void f1(int a)
{
    while (a)
    {
        --a;
        g();
    }
}

/*
1. 'a' передается через регистр edi и сохраняется в ячейке rbp-4:
        mov     dword ptr [rbp - 4], edi
3. 'a' сравнивается с 0, если равно, то происходит переход по .LBB0_3, где
расположен эпилог функции. В противном случае выполняется тело цикла, после
которого происходит безусловный переход по .LBB0_1, т.е. счетчик комманд снова
указывает на первую инструкцию цикла -- сравнение 'a' с 0 (для краткости тело цикло опущено):
.LBB0_1:                                # =>This Inner Loop Header: Depth=1
        cmp     dword ptr [rbp - 4], 0
        je      .LBB0_3
        ...
        jmp     .LBB0_1
В теле цикла 'a' уменьшается на единицу и происходит вызов функции g():
        mov     eax, dword ptr [rbp - 4]
        add     eax, -1
        mov     dword ptr [rbp - 4], eax
*/

void f2(int a)
{
L:
    if (a)
    {
        --a;
        g();
        goto L;
    }
}

/*
Получившийся код идентичен тому, что был получен в предыдущем примере.
*/

void f3(int *p)
{
    for (int i = 0 ; i < 10 ; ++i)
    {
        ++*p;
        if (*p == 5) continue;
        ++*p;
    }
}

/*
1. 'p' передается через регистр rdi и сохраняется в ячейке rbp-8:
        mov     qword ptr [rbp - 8], rdi
5. 'i' хранится в ячейке rbp-12:
         mov     dword ptr [rbp - 12], 0
3. 'i' сравнивается с 10, если больше или равно, происходит переход по адресу
.LBB0_6, где расположен эпилог функции. В противном случае далее выполняется
тело цикла, которое следует сразу за инструкцией условного перехода (jge
.LBB0_6). После тела цикла 'i' увеличивается на 1 и происходит безусловный
переход по адресу .LBB0_1, т.е. началу цикла:
.LBB0_1:                                # =>This Inner Loop Header: Depth=1
        cmp     dword ptr [rbp - 12], 10
        jge     .LBB0_6
        ...
        ...
.LBB0_5:                                #   in Loop: Header=BB0_1 Depth=1
        mov     eax, dword ptr [rbp - 12]
        add     eax, 1
        mov     dword ptr [rbp - 12], eax
        jmp     .LBB0_1
В зависимости от содержания *p на момент проверки в той или иной итерации
цикла, итерация может завершиться "досрочно". В этом фрагменте кода 'p'
копируется в rax, затем значение в rax используется как адрес ячейки, значение
которой сравнивается с 5. Если равно, происходит переход по адресу .LBB0_4, где
находится оставшаяся часть тела цикла, в противном случае счетчик команд
переходит к следующей инструкции, которая является безусловным переходом по
адресу .LBB0_5:
        mov     rax, qword ptr [rbp - 8]
        cmp     dword ptr [rax], 5
        jne     .LBB0_4
        jmp     .LBB0_5
*/